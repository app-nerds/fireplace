/* v1.6.0 */
const fetch$1=window.fetch.bind(window),debounce=(t,n=400)=>{let o=null;return function(){let e=arguments;clearTimeout(o),o=setTimeout(()=>{t.apply(this,e)},n)}},objectToMap=(e={})=>{let t=new Map;for(const n in e)t.set(n,e[n]);return t};async function fetcher(e,t,n){let o;n&&(o=setTimeout(()=>{n.show()},1e3));e=await fetch(e,t);return n&&(clearTimeout(o),n.hide()),e}class BaseView extends HTMLElement{constructor(e,t){super(),this._title="",this.params=e,this._state={},this._onRenderComplete=window._router.onRenderComplete||null,this.router=window._router}async connectedCallback(){await this.beforeRender(),await this.render(),this._setDocumentTitle(),await this.afterRender(),this._onRenderComplete&&this._onRenderComplete(this)}disconnectedCallback(){this.onUnload()}_setDocumentTitle(){var e=this.querySelectorAll("title");e&&0<e.length&&(this._title=e[0].innerText,document.title=this._title,this.removeChild(e[0]))}async beforeRender(){}async afterRender(){}async onUnload(){}async render(){throw new Error("not implemented")}get title(){return this._title}get html(){return this._html}get state(){return this._state}set state(e){this._state=e}getQueryParam(e){return this.router.getQueryParam(e)}navigateTo(e,t={},n={}){this.router.navigateTo(e,t,n)}}class DefaultPageNotFound extends BaseView{constructor(e){super(e)}async render(){return`
			<title>Page Not Found</title>
			<p>The page ${this.params.path} could not be found.</p>
		`}}customElements.define("default-page-not-found",DefaultPageNotFound);class Router{constructor(e,t,n=null){this.targetEl=e,this.routes=t,this.pageNotFoundView=n,this.beforeRoute=null,this.afterRoute=null,this.injectParams=null,this.onRenderComplete=null,this.pageNotFoundView?this.routes.push({path:"/404notfound/:path",view:this.pageNotFoundView}):this.routes.push({path:"/404notfound/:path",view:DefaultPageNotFound})}_pathToRegex(e){return new RegExp("^"+e.replace(/\//g,"\\/").replace(/:\w+/g,"(.+)")+"$")}_getParams(e){let t=0;var n=e.result.slice(1),o=Array.from(e.route.path.matchAll(/:(\w+)/g)).map(e=>e[1]);let r={};for(t=0;t<n.length;t++)r[o[t]]=n[t];if(this.injectParams){var i=this.injectParams(e);for(const a in i)r[a]=i[a]}return r}async _route(e){let t={};e.state&&(t=e.state);const n=this.routes.map(e=>({route:e,result:location.pathname.match(this._pathToRegex(e.path))}));let o=n.find(e=>null!==e.result);if(o){if(!this.beforeRoute||!1!==this.beforeRoute.apply(this,o.route)){e=this._getParams(o);const r=new o.route.view(e),i=(r.state=t,document.querySelector(this.targetEl));i.innerHTML="",i.appendChild(r),this.afterRoute&&this.afterRoute(o.route)}}else this.navigateTo("/404notfound"+location.pathname)}getQueryParam(e){let t=new URLSearchParams(location.search);return t.get(e)}navigateTo(e,t={},n={}){let o="";if(0<Object.keys(t).length){var r,i,t=objectToMap(t);o+="?";for([r,i]of t){var a=encodeURIComponent(r);let e=i;"object"==typeof i&&(e=JSON.stringify(i));var s=encodeURIComponent(e);o+=a+`=${s}&`}}history.pushState(n,null,""+e+o),this._route({state:n})}}class GraphQL{constructor(e,t={http:fetcher,tokenGetterFunction:null,expiredTokenCallback:null,spinner:null}){t={http:fetcher,tokenGetterFunction:null,expiredTokenCallback:null,spinner:null,...t},this.queryURL=e,this.http=t.http,this.tokenGetterFunction=t.tokenGetterFunction,this.expiredTokenCallback=t.expiredTokenCallback,this.spinner=t.spinner}async query(n){if(!this.expiredTokenCallback||this.expiredTokenCallback()){var o=this.tokenGetterFunction?this.tokenGetterFunction():"";n=`query {
			${n}
		}`;let e={method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({query:n})},t=(o&&(e.headers.Authorization="Bearer "+o),await this.http(this.queryURL,e,this.spinner));if(400!==t.status&&401!==t.status){n=await t.json();if(t.ok)return n;throw new Error(n.message)}this.expiredTokenCallback&&this.expiredTokenCallback(t)}}async mutation(n){if(!this.expiredTokenCallback||this.expiredTokenCallback()){var o=this.tokenGetterFunction?this.tokenGetterFunction():"";n=`mutation {
			${n}
		}`;let e={method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({query:n})},t=(o&&(e.headers.Authorization="Bearer "+o),await this.http(this.queryURL,e,this.spinner));if(400!==t.status&&401!==t.status){n=await t.json();if(t.ok)return n;throw new Error(n.message)}this.expiredTokenCallback&&this.expiredTokenCallback()}}}const ErrTokenExpired="token expired";class SessionService{static clearToken(){window.sessionStorage.removeItem("token")}static getToken(){return window.sessionStorage.getItem("token")}static hasToken(){return null!==window.sessionStorage.getItem("token")}static navigateOnTokenExpired(e,t){e.message===ErrTokenExpired&&(SessionService.clearToken(),window.navigateTo(t))}static setToken(e){window.sessionStorage.setItem("token",e)}static tokenExpireFunc(e,t){return e&&401===e.status?(SessionService.clearToken(),SessionService.navigateOnTokenExpired({message:ErrTokenExpired},t),!1):!!SessionService.hasToken()||(SessionService.navigateOnTokenExpired({message:ErrTokenExpired},t),!1)}}const application=(e,t,n=DefaultPageNotFound)=>(window._router=new Router(e,t,n),window.navigateTo=window._router.navigateTo.bind(window._router),window.addEventListener("popstate",e=>{window._router._route({state:e.state})}),{routes:t,targetElement:e,router:window._router,afterRoute:e=>{window._router.afterRoute=e.bind(window._router)},beforeRoute:e=>{window._router.beforeRoute=e.bind(window._router)},injectParams:e=>{window._router.injectParams=e.bind(window._router)},onRenderComplete:e=>{window._router.onRenderComplete=e.bind(window._router)},go:()=>{window._router._route({})}});export{BaseView,DefaultPageNotFound,ErrTokenExpired,GraphQL,Router,SessionService,application,debounce,fetch$1 as fetch,fetcher};